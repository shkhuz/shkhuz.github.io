<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>An experimental systems programming language</title>
<link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
<link rel="manifest" href="/assets/site.webmanifest">
<link rel=stylesheet href="/style.css">

<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
</head>

<body>
<article>
<h1 id="huzaifa-an-experimental-systems-programming-language"><a href="/">huzaifa</a> / An experimental systems programming language</h1>
<h2 id="motivation">Motivation</h2>
<p>The equation <span class="math inline">\(f(a)=\frac{1}{2πi}∮_γ\frac{f(z)}{z-a}\,dz. \tag{1} \label{eq:1}\)</span> is not a derivative.</p>
<p><span class="math display">\[
\begin{align*}
&amp;a + bqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqi\\
\text{where }&amp;i = \sqrt{-1}
\end{align*}
\]</span></p>
<p>A lot of the language features were inspired or taken over from Rust &amp; Zig. However, both of them fill a niche of people that I am not a part of.</p>
<p>Rust is over-engineered, and feels lile a feature-bloat now (some C++ developers might not agree). Zig came close, but I had <em>some</em> problems. After mailing Andrew about these nitpicks and never getting a reply back, I decided to implement a compiler — just for fun.</p>
<p>One gripe I had about C was its header system: it was a mess. I decided to keep the basic feature set of C and add a tiny module system.</p>
<p>As macros were a pain for debugging, I reiterated over the Zig’s <code>comptime</code> feature. In Zig, functions can accept types as arguments, but I didn’t like that idea because of <code>extern</code> functions and FFI stuff.</p>
<p>I decided to implement a <code>macro</code> statement, which can accept an AST node as an argument. How it differs from a traditional macro is that it does not modify the AST — it modifies the generated machine code. This small change makes it possible to namespace macros and package it into a module.</p>
<p>Of course, compile-time asserts and conditionals are possible in regular functions too.</p>
<p>One thing Zig implemented perfectly is the error-handling mechanism. A small addition to the return type of a function makes it possible to handle errors in a clean and runtime-safe way.</p>
<p>I decided to do the same in Aria, but felt the need of naming errors sets to be redundant.</p>
<p>Rust had another syntactical element which hoped to increase developer productivity. As naming variables is hard, variables in Rust can be redeclared in the <em>same</em> scope—and with a different type too.</p>
<p>As the compiler does not warn about this redeclaration (as far as I know), I worried about name collisions going unnoticed and creating hard-to-trace bugs. For this, I decided to introduce a keyword <code>redef</code> that redeclares something in the same scope, when the programmer consciously wants to do it. It might seem like a naive design choice, but if it reduces bugs, I’m on it.</p>
<h2 id="building">Building</h2>
<p><del>As the project is not fully mature yet, I have decided to build the compiler in private — once the compiler is able to bootstrap itself, I will release the repository online.</del> I have now decided to release the repository earlier than planned due to multiple collaborators working on it.</p>
<h2 id="sample-code">Sample Code</h2>
<pre class="aria"><code>module math {
    struct Vector2 {
        x, y: f32,

        proc add(self, other: Vector2) {
            Self {
                x: self.x + other.x,
                y: self.y + other.y,
            }
        }
    }
}
</code></pre>
<h3 id="generics">Generics</h3>
<pre class="aria"><code>proc max<T>(a: T, b: T) T {
    if a > b { a }
    else { b }
}
</code></pre>
<h3 id="errors">Errors</h3>
<pre class="aria"><code><span class="i">@import</span>(<span class="s">"std"</span>);

proc allocate_memory(n: usize) ![]u8 {
    let mem = std::gp_allocator_mem(n)?;
    std::slice::from_raw(mem, n)
}
</code></pre>
<h3 id="optionals">Optionals</h3>
<pre class="aria"><code><span class="i">@import</span>(<span class="s">"std"</span>);

proc main() {
    std::printf(if open_file(<span class="s">"test.txt"</span>) {
        <span class="s">"file successfully opened"</span>
    } else {
        <span class="s">"file cannot be opened"</span>
    });
}

proc open_file(fpath: string) ?std::File {
    if std::os::openf(fpath, std::io::rb) with file {
        file
    } else {
        none
    }
}
</code></pre>
<h3 id="read-user-input">Read User Input</h3>
<pre class="aria"><code><span class="i">@import</span>(<span class="s">"std"</span>);

proc main() !void {
    let input = std::io::read_to_string()?;
    defer free(input);
    redef input = input as []<span class="k">const</span> u8;
}
</code></pre>
<h3 id="conditional-compilation">Conditional Compilation</h3>
<pre class="aria"><code><span class="i">@import</span>(<span class="s">"std"</span>);

proc main() !void {
    std::writeln(static match std::os::host_os {
        std::os::OsType::UNIX => <span class="s">"we are on *NIX"</span>,
        std::os::OsType::Windows => <span class="s">"windows."</span>,
        else => <span class="s">"something else. hmm..."</span>,
    });
}
</code></pre>
</article>
</body>
</html>
