<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>

<title></title>
<link rel='apple-touch-icon' sizes='180x180' href='/assets/apple-touch-icon.png'>
<link rel='icon' type='image/png' sizes='32x32' href='/assets/favicon-32x32.png'>
<link rel='icon' type='image/png' sizes='16x16' href='/assets/favicon-16x16.png'>
<link rel='manifest' href='/assets/site.webmanifest'>
<link rel='stylesheet' href='/style.css'>

<!-- Google tag (gtag.js) -->
<script async src='https://www.googletagmanager.com/gtag/js?id=G-QQS3D5BETB'></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-QQS3D5BETB');
</script>

<script data-host='https://microanalytics.io' data-dnt='false' src='https://microanalytics.io/js/script.js' id='ZwSg9rf6GA' async defer></script>

<script id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js'></script>

<script>
(function() {
  var h, a, f;
  a = document.getElementsByTagName('link');
  for (h = 0; h < a.length; h++) {
    f = a[h];
    if (f.rel.toLowerCase().match(/stylesheet/) && f.href) {
      var g = f.href.replace(/(&|\?)rnd=\d+/, '');
      f.href = g + (g.match(/\?/) ? '&' : '?');
      f.href += 'rnd=' + (new Date().valueOf());
    }
  } // for
})()
</script>

</head>

<body>
<article>
  <nav id='main-nav'>
    <h1><a href='/'>~/</a> 
      Aria language reference
    </h1>
  </nav>
  <h2>
    Hello world
  </h2>
  <pre><code>import std;

fn main() {
    std.print("Hello world!\n");
}</code></pre>
  <h2>
    Variables
  </h2>
  <pre><code>imm a = 1;
mut b = 2;
imm c: u32 = 2;</code></pre>
  <h2>
    Functions
  </h2>
  <pre><code>fn b() {}
fn b(a: u32) {}
fn c() u8 {}</code></pre>
  <h2>
    Arrays
  </h2>
  <pre><code>imm a = .{1, 2, 3};
mut c = b[0];
mut sz = b.len;</code></pre>
  <h2>
    Pointers
  </h2>
  <pre><code>mut a: usize = 1;
mut p: *usize = &amp;a;
mut immp: *imm usize = &amp;a;
mut b = p.*;</code></pre>
  <h2>
    Slices
  </h2>
  <pre><code>imm a: [3]u8 = .{1, 2, 3};
mut b: []u8 = &amp;a;
mut c = b[0];
mut sz = b.len;</code></pre>
  <h2>
    Expression blocks
  </h2>
  <pre><code>imm a = {
    imm b = 1;
    yield b;
};</code></pre>
  <h2>
    Loops
  </h2>
  <pre><code>for (mut i = 0u8; i &lt; 10; i += 1) {}    // normal loop
for (b; e) {}                           // iterating over slice
for (b; *e) {}                          // iterating over slice with ptr
for (b; *e, i) {}
while (true) {}         
while (a; n) {}                         // iterating while optional is 
                                        // not null</code></pre>
  <h2>
    Continue & Break
  </h2>
  <pre><code>for (a; n, i) {
    if (i == 10) break;
    else if (i == 15) continue;
}</code></pre>
  <h2>
    If 
  </h2>
  <pre><code>if (a) 1 else 0;
if (a) {} else {}
if (a) {} else if (b) {} else {}
if (a; n) {}                            // unwrapping optional inside if</code></pre>
  <h2>
    Casts
  </h2>
  <pre><code>mut a: u8 = 1;
mut b: u16 = 2;
mut c: u16 = a + b;                     // implicit cast
mut d: u8 = a + to(u8, b);              // explicit cast ??
mut d: u8 = a + u8(b);                  // explicit cast ??</code></pre>
  <h2>
    Optionals
  </h2>
  <pre><code>mut a: ?u8 = 1;
mut b: ?u8 = null;
mut c: u8 = a orelse 0;                 // default value
mut d: u8 = a catch return 0;           // do something on null</code></pre>
  <h2>
    Enums
  </h2>
  <pre><code>imm A = enum {
    a, b, c,
};

mut a = A.a;
mut b = .b;</code></pre>
  <h2>
    Switch
  </h2>
  <pre><code>switch (a) {
    a, b, c =&gt; {},
    else =&gt; {},
}

switch (a) {
    a, b, c (n) =&gt; {},
    else (n) =&gt; {},
}</code></pre>
  <h2>
    Structs
  </h2>
  <pre><code>imm a = struct {
    a: u8,
    b: u16,
    c: u32,
    d: struct {},

    mut e: u8;
    fn f() {}
};</code></pre>
  <h2>
    Unions
  </h2>
  <pre><code>imm a = union {
    a: u8, 
    b: u16,
};</code></pre>
  <h2>
    Tagged Unions
  </h2>
  <pre><code>imm a = union(enum) {
    a: u8,
    b: u16,
}</code></pre>
  <h2>
    Imports
  </h2>
  <pre><code>import basil;                           // imports 'basil.ar' file in cwd
import std;                             // if file not found in cwd, it checks
                                        // inside the lib directory</code></pre>
  <h2>
    Type
  </h2>
  <pre><code>imm A = u32;
imm B = u64;

fn get(a: A, b: type) {}</code></pre>
  <h2>
    Function Pointers
  </h2>
  <pre><code>fn a() {}
imm p: *imm fn() = &amp;a;
p();</code></pre>
  <h2>
    Built-in functions
  </h2>
  <pre><code>imm img = %embedFile("img.bmp");</code></pre>
  <h2>
    Compile-time code evaluation
  </h2>
  <pre><code>fn add(a: u32, b: u32) u32 {
    return a + b;
}

mut a = 2u32;
mut b = 3u32;
// 'c' is known at compile-time
mut c = eval add(a, b);</code></pre>
</article>
</body>
</html>
