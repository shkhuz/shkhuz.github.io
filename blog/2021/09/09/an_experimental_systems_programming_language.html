<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<head>
<title>An experimental systems programming language</title>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet"> 
<link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
<link rel="manifest" href="/assets/site.webmanifest">
<link rel=stylesheet href="/style.css">
</head>

<body>
<article>
<h1>An experimental systems programming language<br><span class='author'>By Huzaifa Shaikh, Sep 09, 2021</span></h1>

<h2>Motivation</h2>

<p>A lot of the language features were inspired or taken over from Rust &amp; Zig.
However, both of them fill a niche of people that I am not a part of.</p>

<p>Rust is over-engineered, and feels lile a feature-bloat now (some C++
developers might not agree). Zig came close, but I had <em>some</em> problems. After
mailing Andrew about these nitpicks and never getting a reply back, I decided
to implement a compiler — just for fun.</p>

<p>One gripe I had about C was its header system: it was a mess. I decided to keep
the basic feature set of C and add a tiny module system.</p>

<p>As macros were a pain for debugging, I reiterated over the Zig&rsquo;s <code>comptime</code>
feature. In Zig, functions can accept types as arguments, but I didn&rsquo;t like
that idea because of <code>extern</code> functions and FFI stuff.</p>

<p>I decided to implement a <code>macro</code> statement, which can accept an AST node as an
argument. How it differs from a traditional macro is that it does not modify
the AST — it modifies the generated machine code. This small change makes it
possible to namespace macros and package it into a module.</p>

<p>Of course, compile-time asserts and conditionals are possible in regular
functions too.</p>

<p>One thing Zig implemented perfectly is the error-handling mechanism. A small
addition to the return type of a function makes it possible to handle errors in
a clean and runtime-safe way.</p>

<p>I decided to do the same in Aria, but felt the need of naming errors sets to be
redundant.</p>

<p>Rust had another syntactical element which hoped to increase developer
productivity. As naming variables is hard, variables in Rust can be redeclared
in the <em>same</em> scope—and with a different type too.</p>

<p>As the compiler does not warn about this redeclaration (as far as I know), I
worried about name collisions going unnoticed and creating hard-to-trace bugs.
For this, I decided to introduce a keyword <code>redef</code> that redeclares something in
the same scope, when the programmer consciously wants to do it. It might seem
like a naive design choice, but if it reduces bugs, I&rsquo;m on it.</p>

<h2>Building</h2>

<p><del>As the project is not fully mature yet, I have decided to build the compiler
in private — once the compiler is able to bootstrap itself, I will release the
repository online.</del> I have now decided to release the repository earlier than
planned due to multiple collaborators working on it.</p>

<h2>Sample Code</h2>

<pre><code>module math {
    struct Vector2 {
        x, y: f32,

        proc add(self, other: Vector2) {
            Self {
                x: self.x + other.x,
                y: self.y + other.y,
            }
        }
    }
}
</code></pre>

<h3>Generics</h3>

<pre><code>proc max&lt;T&gt;(a: T, b: T) T {
    if a &gt; b { a }
    else { b }
}
</code></pre>

<h3>Errors</h3>

<pre><code>@import("std");

proc allocate_memory(n: usize) ![]u8 {
    let mem = std::gp_allocator_mem(n)?;
    std::slice::from_raw(mem, n)
}
</code></pre>

<h3>Optionals</h3>

<pre><code>@import("std");

proc main() {
    std::printf(if open_file("test.txt") {
        "file successfully opened"
    } else {
        "file cannot be opened"
    });
}

proc open_file(fpath: string) ?std::File {
    if std::os::openf(fpath, std::io::rb) with file {
        file
    } else {
        none
    }
}
</code></pre>

<h3>Read User Input</h3>

<pre><code>@import("std");

proc main() !void {
    let input = std::io::read_to_string()?;
    defer free(input);
    redef input = input as []const u8;
}
</code></pre>

<h3>Conditional Compilation</h3>

<pre><code>@import("std");

proc main() !void {
    std::writeln(static match std::os::host_os {
        std::os::OsType::UNIX =&gt; "we are on *NIX",
        std::os::OsType::Windows =&gt; "windows.",
        else =&gt; "something else. hmm...",
    });
}
</code></pre>


<a href="/">back to home page</a>
</article>
</body>
</html>
