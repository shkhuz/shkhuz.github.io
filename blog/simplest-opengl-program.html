<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>

<title>Simplest OpenGL program</title>
<link rel='apple-touch-icon' sizes='180x180' href='/assets/apple-touch-icon.png'>
<link rel='icon' type='image/png' sizes='32x32' href='/assets/favicon-32x32.png'>
<link rel='icon' type='image/png' sizes='16x16' href='/assets/favicon-16x16.png'>
<link rel='manifest' href='/assets/site.webmanifest'>
<link rel='stylesheet' href='/style.css'>

<!-- Google tag (gtag.js) -->
<script async src='https://www.googletagmanager.com/gtag/js?id=G-QQS3D5BETB'></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-QQS3D5BETB');
</script>

<script data-host='https://microanalytics.io' data-dnt='false' src='https://microanalytics.io/js/script.js' id='ZwSg9rf6GA' async defer></script>

<script id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js'></script>

<script>
(function() {
  var h, a, f;
  a = document.getElementsByTagName('link');
  for (h = 0; h < a.length; h++) {
    f = a[h];
    if (f.rel.toLowerCase().match(/stylesheet/) && f.href) {
      var g = f.href.replace(/(&|\?)rnd=\d+/, '');
      f.href = g + (g.match(/\?/) ? '&' : '?');
      f.href += 'rnd=' + (new Date().valueOf());
    }
  } // for
})()
</script>

</head>

<body>
<article>
  <nav id='main-nav'>
    <h1><a href='/'>~/</a> Simplest OpenGL program</h1>
    <span class='info'>Published on May 20, 2024 by <a href='mailto:shk.huz@gmail.com'>shkhuz</a></span>
  </nav>
  <p>
  </p>
  <p>
    This is a single-file OpenGL "hello world" boilerplate implementation. It assumes that SDL and GLEW are already installed.
  </p>
  <div class='code lang-cpp'><pre><span class='intrinsic'>#include</span> &lt;GL/glew.h&gt;
<span class='intrinsic'>#include</span> &lt;SDL2/SDL.h&gt;
<span class='intrinsic'>#include</span> &lt;stdio.h&gt;
<span class='intrinsic'>#include</span> &lt;string&gt;

const std::string vs =
    <span class='string'>"#version 330\n"</span>
    <span class='string'>"layout(location = 0) in vec4 position;\n"</span>
    <span class='string'>"layout(location = 1) in vec4 color;\n"</span>
    <span class='string'>"smooth out vec4 vertex_color;\n"</span>
    <span class='string'>"void main() {\n"</span>
    <span class='string'>"   gl_Position = position;\n"</span>
    <span class='string'>"   vertex_color = color;\n"</span>
    <span class='string'>"}\n"</span>
    <span class='string'>""</span>
    ;

const std::string fs =
    <span class='string'>"#version 330\n"</span>
    <span class='string'>"smooth in vec4 vertex_color;\n"</span>
    <span class='string'>"out vec4 out_color;\n"</span>
    <span class='string'>"void main() {\n"</span>
    <span class='string'>"   out_color = vertex_color;\n"</span>
    <span class='string'>"}\n"</span>
    <span class='string'>""</span>
    ;

bool create_shader(GLenum shader_kind, const <span class='keyword'>char</span>* shader_src, GLuint* out_shader) {
    GLuint shader = glCreateShader(shader_kind);
    glShaderSource(shader, <span class='const'>1</span>, &amp;shader_src, NULL);
    glCompileShader(shader);

    GLint status;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;status);
    <span class='keyword'>if</span> (status == GL_FALSE) {
        GLint log_len;
        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;log_len);

        GLchar log[<span class='const'>4096</span>];
        glGetShaderInfoLog(shader, log_len, NULL, log);

        const <span class='keyword'>char</span>* kind;
        switch (shader_kind) {
            case GL_VERTEX_SHADER: kind = <span class='string'>"vertex"</span>; break;
            case GL_FRAGMENT_SHADER: kind = <span class='string'>"fragment"</span>; break;
            default: kind = <span class='string'>"unknown"</span>; break;
        }
        fprintf(stderr, <span class='string'>"Compile failure in %s shader: %s\n"</span>, kind, log);
        <span class='keyword'>return</span> <span class='const'>false</span>;
    }
    *out_shader = shader;
    <span class='keyword'>return</span> <span class='const'>true</span>;
}

bool build_shader_program(const <span class='keyword'>char</span>* vs, const <span class='keyword'>char</span>* fs, GLuint* out_program) {
    GLuint vshader;
    GLuint fshader;

    <span class='keyword'>if</span> (!create_shader(GL_VERTEX_SHADER, vs, &amp;vshader)) <span class='keyword'>return</span> <span class='const'>false</span>;
    <span class='keyword'>if</span> (!create_shader(GL_FRAGMENT_SHADER, fs, &amp;fshader)) <span class='keyword'>return</span> <span class='const'>false</span>;

    GLuint program = glCreateProgram();

    glAttachShader(program, vshader);
    glAttachShader(program, fshader);

    glLinkProgram(program);

    GLint status;
    glGetProgramiv(program, GL_LINK_STATUS, &amp;status);
    <span class='keyword'>if</span> (status == GL_FALSE) {
        GLint log_len;
        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;log_len);

        GLchar log[<span class='const'>4096</span>];
        glGetProgramInfoLog(program, log_len, NULL, log);
        fprintf(stderr, <span class='string'>"Shader linker failure: %s\n"</span>, log);
        <span class='keyword'>return</span> <span class='const'>false</span>;
    }

    glDetachShader(program, vshader);
    glDetachShader(program, fshader);

    *out_program = program;
    <span class='keyword'>return</span> <span class='const'>true</span>;
}

<span class='keyword'>int</span> main() {
    <span class='keyword'>if</span> (SDL_Init(SDL_INIT_VIDEO) &lt; <span class='const'>0</span>) <span class='keyword'>return</span> <span class='const'>1</span>;
    SDL_Window *window = SDL_CreateWindow(<span class='string'>"SDL"</span>,
        SDL_WINDOWPOS_UNDEFINED,
        SDL_WINDOWPOS_UNDEFINED,
        <span class='const'>640</span>, <span class='const'>480</span>,
        SDL_WINDOW_SHOWN | SDL_WINDOW_OPENGL
    );

    SDL_GLContext gl_context = SDL_GL_CreateContext(window);
    <span class='keyword'>if</span> (gl_context == NULL) {
        fprintf(stderr, <span class='string'>"Error in creating the OpenGL context\n"</span>);
        <span class='keyword'>return</span> <span class='const'>1</span>;
    }

    const unsigned <span class='keyword'>char</span>* version = glGetString(GL_VERSION);
    <span class='keyword'>if</span> (version == NULL) {
        fprintf(stderr, <span class='string'>"Error in getting the OpenGL version\n"</span>);
        <span class='keyword'>return</span> <span class='const'>1</span>;
    }

    SDL_GL_MakeCurrent(window, gl_context);

    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, <span class='const'>3</span>);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, <span class='const'>3</span>);

    <span class='comment'>// MUST make a context AND make it current BEFORE glewInit()!</span>
    glewExperimental = GL_TRUE;
    GLenum glew_status = glewInit();
    <span class='keyword'>if</span> (glew_status != <span class='const'>0</span>) {
        fprintf(stderr, <span class='string'>"GLEW init error: %s\n"</span>, glewGetErrorString(glew_status));
        <span class='keyword'>return</span> <span class='const'>1</span>;
    }

    const <span class='keyword'>float</span> triangle_vertices[] = {
        <span class='comment'>// position</span>
         <span class='const'>0.0</span>f,  <span class='const'>0.5</span>f,   <span class='const'>0.0</span>f, <span class='const'>1.0</span>f,
         <span class='const'>0.5</span>f, <span class='const'>-0.366</span>f, <span class='const'>0.0</span>f, <span class='const'>1.0</span>f,
        <span class='const'>-0.5</span>f, <span class='const'>-0.366</span>f, <span class='const'>0.0</span>f, <span class='const'>1.0</span>f,

        <span class='comment'>// color</span>
        <span class='const'>1.0</span>f, <span class='const'>0.0</span>f, <span class='const'>0.0</span>f, <span class='const'>1.0</span>f,
        <span class='const'>0.0</span>f, <span class='const'>1.0</span>f, <span class='const'>0.0</span>f, <span class='const'>1.0</span>f,
        <span class='const'>0.0</span>f, <span class='const'>0.0</span>f, <span class='const'>1.0</span>f, <span class='const'>1.0</span>f
    };

    GLuint shader_program;
    <span class='keyword'>if</span> (!build_shader_program(vs.c_str(), fs.c_str(), &amp;shader_program)) {
        SDL_Quit();
        <span class='keyword'>return</span> <span class='const'>0</span>;
    }

    GLuint vao;
    glGenVertexArrays(<span class='const'>1</span>, &amp;vao);
    glBindVertexArray(vao);

    GLuint triangle_vbo;
    glGenBuffers(<span class='const'>1</span>, &amp;triangle_vbo);

    glBindBuffer(GL_ARRAY_BUFFER, triangle_vbo);
    glBufferData(
        GL_ARRAY_BUFFER,
        sizeof(triangle_vertices),
        triangle_vertices,
        GL_STATIC_DRAW
    );
    glEnableVertexAttribArray(<span class='const'>0</span>);
    glEnableVertexAttribArray(<span class='const'>1</span>);
    glVertexAttribPointer(<span class='const'>0</span>, <span class='const'>4</span>, GL_FLOAT, GL_FALSE, <span class='const'>0</span>, <span class='const'>0</span>);
    glVertexAttribPointer(<span class='const'>1</span>, <span class='const'>4</span>, GL_FLOAT, GL_FALSE, <span class='const'>0</span>, (<span class='keyword'>void</span>*)<span class='const'>48</span>);
    glBindVertexArray(<span class='const'>0</span>);

    bool running = <span class='const'>true</span>;
    <span class='keyword'>while</span> (running) {
        SDL_Event e;
        <span class='keyword'>while</span> (SDL_PollEvent(&amp;e)) {
            <span class='keyword'>if</span> (e.type == SDL_QUIT ||
                (e.type == SDL_KEYUP &amp;&amp; e.key.keysym.sym == SDLK_ESCAPE)) {
                running = <span class='const'>false</span>;
            }
        }

        glClearColor(<span class='const'>0.0</span>, <span class='const'>0.0</span>, <span class='const'>0.0</span>, <span class='const'>0.0</span>);
        glClear(GL_COLOR_BUFFER_BIT);

        glUseProgram(shader_program);
        glBindVertexArray(vao);
        glDrawArrays(GL_TRIANGLES, <span class='const'>0</span>, <span class='const'>3</span>);
        glUseProgram(<span class='const'>0</span>);

        SDL_GL_SwapWindow(window);
        SDL_Delay(<span class='const'>20</span>);
    }

    SDL_GL_DeleteContext(gl_context);
    SDL_Quit();
    <span class='keyword'>return</span> <span class='const'>0</span>;
}
</pre></div>
  <div class='code-snippet-filename'>sdl2-opengl.cpp</div>
  <p>
    Compile with:
  </p>
  <div class='code lang-console'><pre><span class='console-prompt'>$ </span><span class='console-input'>g++ sdl2-opengl.cpp -Wall -lSDL2 -lGL -lGLEW</span>
</pre></div>
  <p>
    <img src='assets/opengl-hello-world-triangle.png' alt=''>
  </p>
</article>
</body>
</html>
